using Xunit;
using fastdee.Stratum.Notification;
using System;
using System.Linq;

namespace fastdee.Tests
{
    public class WorkGeneratorTests
    {
        [Theory]
        [InlineData(
            new byte[] { // expected work data header result
                0x20, 0x00, 0x00, 0x00, 0xbb, 0x08, 0x74, 0xfb, 0x97, 0x5c, 0x4d, 0xff, 0x98, 0x72, 0xe9, 0x88,
                0x77, 0xe3, 0xf9, 0xc8, 0x22, 0x9f, 0x9b, 0x87, 0xf0, 0xf9, 0xff, 0x04, 0x00, 0x00, 0x0c, 0x9a,
                0x00, 0x00, 0x00, 0x00, 0xf0, 0x0a, 0xed, 0xae, 0x36, 0x2d, 0xdc, 0xee, 0x50, 0x8e, 0x12, 0x8f,
                0xc8, 0xe0, 0xa4, 0x0a, 0xff, 0xb7, 0x6e, 0xcd, 0xb0, 0xbf, 0xe7, 0x57, 0x08, 0x45, 0xfb, 0x11,
                0x97, 0xe4, 0xda, 0x23, 0x5f, 0xdf, 0x98, 0x11, 0x1a, 0x0e, 0xde, 0xd9, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            },
            new byte[] { // nonce1
                0x08, 0x00, 0x22, 0xb3
            }, 4, // nonce2 size

            // Overall state
            0, // nonce2

            // "new job"
            "3ebe",
            new byte[] { // prevhash
                0xbb, 0x08, 0x74, 0xfb, 0x97, 0x5c, 0x4d, 0xff, 0x98, 0x72, 0xe9, 0x88, 0x77, 0xe3, 0xf9, 0xc8,
                0x22, 0x9f, 0x9b, 0x87, 0xf0, 0xf9, 0xff, 0x04, 0x00, 0x00, 0x0c, 0x9a, 0x00, 0x00, 0x00, 0x00,
            }, null,
            new byte[] { // coinb1
                0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x4e, 0x03, 0x95, 0x96, 0x00, 0x04, 0x11,
                0x98, 0xdf, 0x5f, 0x08, 0xfa, 0xbe, 0x6d, 0x6d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
            },
            new byte[] { // coinb2
                0x0f, 0x2f, 0x4d, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x2d, 0x44, 0x75, 0x74, 0x63, 0x68, 0x32, 0x2f,
                0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x6a, 0x24,
                0xaa, 0x21, 0xa9, 0xed, 0x96, 0x2d, 0xae, 0x8f, 0x68, 0x16, 0x3b, 0x65, 0x09, 0x17, 0xdf, 0xca,
                0x26, 0x50, 0x6b, 0x8a, 0xc8, 0x68, 0xd8, 0x53, 0xad, 0x11, 0x5f, 0xa2, 0xc9, 0x0f, 0xf2, 0xb2,
                0x05, 0xa5, 0x6a, 0xcc, 0x5f, 0xcf, 0x17, 0xa8, 0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x14, 0x92,
                0x3a, 0xe3, 0xdf, 0x6b, 0x46, 0xc6, 0x69, 0xe3, 0x75, 0xf6, 0x38, 0x93, 0x39, 0xad, 0xce, 0x9d,
                0xb0, 0xdf, 0x6e, 0x00, 0x00, 0x00, 0x00
            }, // merkles come later
            new byte[] { 0x20, 0x00, 0x00, 0x00 }, // version
            new byte[] { 0x1a, 0x0e, 0xde, 0xd9 }, // nbits - network difficulty
            new byte[] { 0x5f, 0xdf, 0x98, 0x11 }, // ntime
            true, // clean - flush nonces
            new byte[] {
                0x18, 0x9c, 0x02, 0x15, 0xf3, 0x53, 0x41, 0x14, 0x83, 0x0b, 0x6c, 0x42, 0x12, 0x28, 0xbf, 0x00,
                0x57, 0x08, 0x40, 0xd3, 0xc5, 0xa6, 0x0c, 0xe6, 0x22, 0x0e, 0xd0, 0xe5, 0x0c, 0x3e, 0x61, 0x40
            },
            new byte[] {
                0xf1, 0xab, 0x49, 0x61, 0x54, 0x1e, 0xc5, 0x98, 0xf5, 0xd5, 0xb4, 0xa9, 0xa8, 0x8a, 0xb1, 0x0b,
                0x1b, 0xa1, 0x62, 0x80, 0x8c, 0x04, 0x79, 0x8e, 0x74, 0x90, 0x74, 0xe8, 0x8b, 0xd0, 0xe6, 0x08
            }
        )]
        public void MatchesGoldenCanonWithMerkles(byte[] expected, byte[] n1, ushort n2sz, ulong nonce2, string jobid, byte[] prevHash, byte[] trie, byte[] coinhead, byte[] cointail, byte[] version, byte[] nbits, byte[] ntime, bool clean, params byte[][] merkles)
        {
            var uut = new WorkGenerator(fastdee.PoolOps.Merkles.SingleSha);
            var pack = new NewJob(jobid, version, trie, coinhead, cointail, nbits, ntime, clean);
            Array.Copy(prevHash, pack.prevBlock.blob, pack.prevBlock.blob.Length);
            pack.merkles.AddRange(merkles.Select(el => AsMerkle(el)));
            uut.NextNonce(nonce2);
            uut.NonceSettings(n1, n2sz);
            uut.NewJob(pack);
            Assert.Equal(expected, uut.Header.ToArray());
        }


        static Mining.Merkle AsMerkle(ReadOnlySpan<byte> blob) {
            var res = new Mining.Merkle();
            for (var cp = 0; cp < blob.Length; cp++) res.blob[cp] = blob[cp];
            return res;
        }
    }
}
