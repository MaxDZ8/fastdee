using fastdee.Devices;
using fastdee.Stratum;
using fastdee.PoolOps;
using Xunit;
using fastdee.Stratum.Notification;

namespace fastdee.Tests.Devices
{
    public class TrackerTests
    {
        /// <summary>
        /// The goal of the <see cref="Tracker"/> is to generate and track the work given to devices.
        /// Created trackers have no devices.
        /// </summary>
        [Fact]
        public void CanCreateEmpty()
        {
            var test = new Tracker<int>(MakeFedWorkGenerator());
            Assert.Equal(0u, test.DeviceCount);
        }

        /// <summary>
        /// Add devices by giving new addresses. The address is key.
        /// </summary>
        [Fact]
        public void AddedDevicesAreIdle()
        {
            var test = new Tracker<int>(MakeFedWorkGenerator());
            test.ConsumeNonces(0, 123456);
            Assert.Equal(1u, test.DeviceCount);
        }

        [Fact]
        public void DevicesAreByAddress()
        {
            var test = new Tracker<int>(MakeFedWorkGenerator());
            test.ConsumeNonces(0, 123456);
            test.ConsumeNonces(1, 789000);
            test.ConsumeNonces(2, 101112);
            test.ConsumeNonces(0, 654321);
            Assert.Equal(3u, test.DeviceCount);
        }

        [Fact]
        public void CanFlush()
        {
            var test = new Tracker<int>(MakeFedWorkGenerator());
            test.ConsumeNonces(0, 123456);
            test.ConsumeNonces(1, 789000);
            test.ConsumeNonces(2, 101112);
            test.ConsumeNonces(0, 654321);
            test.FlushOldies(System.TimeSpan.Zero);
            Assert.Equal(0u, test.DeviceCount);
        }

        [Fact]
        public void UnknownWorkIsNullWork()
        {
            var test = new Tracker<int>(MakeFedWorkGenerator());
            var work = test.RetrieveOriginal(123);
            Assert.Null(work);
        }

        [Fact]
        public void GoodDeviceWorkHadOriginalWork()
        {
            var test = new Tracker<int>(MakeFedWorkGenerator());
            var work = test.ConsumeNonces(0, 1234);
            var ori = test.RetrieveOriginal(work.wid);
            Assert.NotNull(ori);
        }

        static HeaderGenerator MakeFedWorkGenerator() {
            var uut = new HeaderGenerator(Merkles.SingleSha);
            var pack = new NewJob(jobid, version, null, coinhead, cointail, nbits, ntime, true);
            System.Array.Copy(prevhash, pack.prevBlock.blob, pack.prevBlock.blob.Length);
            pack.merkles.AddRange(merkles);
            uut.NextNonce(0);
            uut.NonceSettings(nonce1, 4);
            uut.NewJob(pack);
            return uut;
        }

        static readonly string jobid = "abcd";
        static readonly byte[] version = new byte[] { 0x20, 0x00, 0x00, 0x00 };
        static readonly byte[] nbits = new byte[] { 0x1a, 0x0e, 0xde, 0xd9 };
        static readonly byte[] ntime = new byte[] { 0x5f, 0xdf, 0x98, 0x11 };
        static readonly byte[] coinhead = new byte[]
        {
                0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x4e, 0x03, 0x95, 0x96, 0x00, 0x04, 0x11,
                0x98, 0xdf, 0x5f, 0x08, 0xfa, 0xbe, 0x6d, 0x6d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        };
        static readonly byte[] cointail = new byte[]
        {
                0x0f, 0x2f, 0x4d, 0x69, 0x6e, 0x69, 0x6e, 0x67, 0x2d, 0x44, 0x75, 0x74, 0x63, 0x68, 0x32, 0x2f,
                0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x26, 0x6a, 0x24,
                0xaa, 0x21, 0xa9, 0xed, 0x96, 0x2d, 0xae, 0x8f, 0x68, 0x16, 0x3b, 0x65, 0x09, 0x17, 0xdf, 0xca,
                0x26, 0x50, 0x6b, 0x8a, 0xc8, 0x68, 0xd8, 0x53, 0xad, 0x11, 0x5f, 0xa2, 0xc9, 0x0f, 0xf2, 0xb2,
                0x05, 0xa5, 0x6a, 0xcc, 0x5f, 0xcf, 0x17, 0xa8, 0x04, 0x00, 0x00, 0x00, 0x16, 0x00, 0x14, 0x92,
                0x3a, 0xe3, 0xdf, 0x6b, 0x46, 0xc6, 0x69, 0xe3, 0x75, 0xf6, 0x38, 0x93, 0x39, 0xad, 0xce, 0x9d,
                0xb0, 0xdf, 0x6e, 0x00, 0x00, 0x00, 0x00
        };
        static readonly byte[] prevhash = new byte[]
        {
                0xbb, 0x08, 0x74, 0xfb, 0x97, 0x5c, 0x4d, 0xff, 0x98, 0x72, 0xe9, 0x88, 0x77, 0xe3, 0xf9, 0xc8,
                0x22, 0x9f, 0x9b, 0x87, 0xf0, 0xf9, 0xff, 0x04, 0x00, 0x00, 0x0c, 0x9a, 0x00, 0x00, 0x00, 0x00,
        };
        static readonly byte[] nonce1 = new byte[] { 0x08, 0x00, 0x22, 0xb3 };
        static readonly Mining.Merkle[] merkles = new Mining.Merkle[] {
            AsMerkle(
                0x18, 0x9c, 0x02, 0x15, 0xf3, 0x53, 0x41, 0x14, 0x83, 0x0b, 0x6c, 0x42, 0x12, 0x28, 0xbf, 0x00,
                0x57, 0x08, 0x40, 0xd3, 0xc5, 0xa6, 0x0c, 0xe6, 0x22, 0x0e, 0xd0, 0xe5, 0x0c, 0x3e, 0x61, 0x40
            ),
            AsMerkle(
                0xf1, 0xab, 0x49, 0x61, 0x54, 0x1e, 0xc5, 0x98, 0xf5, 0xd5, 0xb4, 0xa9, 0xa8, 0x8a, 0xb1, 0x0b,
                0x1b, 0xa1, 0x62, 0x80, 0x8c, 0x04, 0x79, 0x8e, 0x74, 0x90, 0x74, 0xe8, 0x8b, 0xd0, 0xe6, 0x08
            )
        };

        static Mining.Merkle AsMerkle(params byte[] blobby)
        {
            var res = new Mining.Merkle();
            System.Array.Copy(blobby, res.blob, res.blob.Length);
            return res;
        }
    }
}
